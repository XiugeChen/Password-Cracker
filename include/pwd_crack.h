/*
  pwd_crack.h

  #### ATTRIBUTION ####
  Xiuge Chen
  xiugec@student.unimelb.edu.au
  Subject: COMP30023 Computer Systems
  University of Melbourne
*/

#ifndef PWD_CRACK_H
#define PWD_CRACK_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "sha256.h"
#include "hash_manage.h"
#include "common_sub.h"

/**** constant ****/
#define BUFFER_SIZE 1024
// number of bits of each byte
#define NUM_BIT_PER_BYTE 8
static char const * const DICT_FILE_PATH = "./resources/passwords/common_passwords.txt";
static const char STRAT_CHAR = ' ';
static const char END_CHAR = '~';

/*
  public interface using to call password cracker
  INPUT: hash_file: mandatory, the file contains all SHA256 hash results (32 bytes for each)
        pwd_file: optional, the file contains all passwords in text,
                  if specified cracker will check each password with hash results
        num_guess: optional, the number of guesses will be performed, -1 if no restriction
        pwd_len: optional, the length of password, -1 if no restriction
*/
void crack_pwd(const char* hash_file, const char* pwd_file, const int num_guess,
  const int pwd_len);

// helper functions
/*
  search passwords
  Try flexible dictionary attack and smart brute force attack first since these
  technologies could help the program verify the mostly likely passwords first.
  Then try lazy brute force attack(check all possible outcomes)
  For detailed description, please refer to README.
*/
void search_pwd(BYTE** hash_result, const int hash_len, const int num_guess,
  const int pwd_len);

/*
  compare password stored inside pwd_file (line by line) with hash results
  stored inside hash_result (32 bytes by 32 bytes)
  Return the number of guessing password stored inside of pwd_file.
*/
void compare_pwd(BYTE** hash_result, const int hash_len, const char* pwd_file);

/*
  Flexible dictionary attack
  Password length has to be specified, it will try to match all the substrings of
  each password in dict_file that has the same length.
  While going through each password (or substrings of passwords), also perform
  smart brute force attack.
  It helps the program to verify those passwords that are more likely to be
  generated by human first.
  For detailed description, please refer to README.
*/
bool dict_attack(BYTE** hash_result, const int hash_len, const int pwd_len,
  int* left_guess, const char* dict_file) ;

/*
  Smart brute force attack, trying differnet expansion of given password by
  combining different following rules:
  a. replace character with its common substitution (human convention.
  b. Capitalize the first character.
  c. add punctuation at the start or end of password
  d. add number at the start or end of password
  For detailed description, please refer to README.
*/
bool smart_bf_attack(BYTE** hash_result, const int hash_len, BYTE* password,
  int* left_guess);

/*
  lazy brute force attack (try all possible outcome)
  **** only support password length 4 ****
  For detailed description, please refer to README.
*/
bool lazy_bf_attack(BYTE** hash_result, const int hash_len, int* left_guess,
  const int pwd_len);

/*
  given a 2D array where contains all possible values of string, brute force
  generate all possible string and try to match the hash results.
*/
bool bf_search_match(BYTE** hash_result, const int hash_len, int* left_guess,
  BYTE** candidate_chars, const int pwd_len);

/*
  check whether the given password matches any hash results, if so, print it out
*/
void check_match(BYTE** hash_result, const int hash_len, BYTE* password);

/*
  get the next line from file descriptor and store it to buffer
*/
bool get_next_line(FILE* fp, BYTE* buffer);

#endif
