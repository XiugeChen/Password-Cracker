/*
  pwd_crack.h

  #### DESCRIPTION ####


  #### ATTRIBUTION ####
  Xiuge Chen
  xiugec@student.unimelb.edu.au
  Subject: COMP30023 Computer Systems
  University of Melbourne
*/

#ifndef PWD_CRACK_H
#define PWD_CRACK_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>

#include <sha256.h>
#include <hash_manage.h>
#include <common_sub.h>
#include <error_check.h>
#include <array_manage.h>

/**** constant ****/
#define BUFFER_SIZE 10240
// number of bits of each byte
#define NUM_BIT_PER_BYTE 8
#define NUM_SUB 4
static char const * const DICT_FILE_PATH = "./resources/passwords/common_passwords.txt";
static const char STRAT_CHAR = ' ';
static const char END_CHAR = '~';

// used for brute force search
static const char NUMBER_LIST[10] = "0123456789";
static const char LOWER_CHAR_LIST[26] = "abcdefghijklmnopqrstuvwxyz";
static const char COMMON_CHAR_LIST[62] = "abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/*
  public interface using to call password cracker
  INPUT: hash_file: mandatory, the file contains all SHA256 hash results (32 bytes for each)
        pwd_file: optional, the file contains all passwords in text,
                  if specified cracker will check each password with hash results
        num_guess: optional, the number of guesses will be performed, -1 if no restriction
        pwd_len: optional, the length of password, -1 if no restriction
*/
void crack_pwd(const char* hash_file, const char* pwd_file, const int num_guess,
  const int pwd_len);

// helper functions
/*
  search passwords
  Try flexible dictionary attack and smart brute force attack first since these
  technologies could help the program verify the mostly likely passwords first.
  Then try lazy brute force attack(check all possible outcomes)
  For detailed description, please refer to README.
*/
void search_pwd(BYTE** hash_result, const int hash_len, const int num_guess,
  const int pwd_len);

/*
  compare password stored inside pwd_file (line by line) with hash results
  stored inside hash_result (32 bytes by 32 bytes)
  Return the number of guessing password stored inside of pwd_file.
*/
void compare_pwd(BYTE** hash_result, const int hash_len, const char* pwd_file);

/*
  Dictionary attack
  Password length has to be specified, it will try to match all the substrings of
  each password in dict_file that has the same length.
  It helps the program to verify those passwords that are more likely to be
  generated by human first, since it is the easiest way for human to memorize
  password by using some meaningful English words.
  For detailed description, please refer to README.
*/
bool dict_attack(BYTE** hash_result, const int hash_len, const int pwd_len,
  int* left_guess, const char* dict_file) ;

/*
  Smart brute force attack, trying differnet expansion of given password by
  substitue num_sub number of chars with their common substitutions, including:
  a. replace character with its common substitution (human convention, like a to @).
  b. Capitalize the character.
  For detailed description, please refer to README.
*/
bool smart_bf_attack(BYTE** hash_result, const int hash_len, const int pwd_len,
  int* left_guess, const char* dict_file, const int num_sub);

/*
  lazy brute force attack (try all possible combination of given list and
  password length)
  For detailed description, please refer to README.
*/
bool lazy_bf_attack(BYTE** hash_result, const int hash_len, int* left_guess,
  const int pwd_len, const char* range_of_char);

/*
  given a 2D array where contains all possible values of string, brute force
  generate all possible string and try to match the hash results.
*/
bool bf_search_match(BYTE** hash_result, const int hash_len, int* left_guess,
  BYTE** candidate_chars, const int pwd_len);

/*
  check whether the given password matches any hash results
  If so, print it out.
*/
void check_match(BYTE** hash_result, const int hash_len, BYTE* password);

/*
  get the next line from file descriptor and store it to buffer
*/
bool get_next_line(FILE* fp, BYTE* buffer);

#endif
