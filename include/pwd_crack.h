/*
  pwd_crack.h

  #### ATTRIBUTION ####
  Xiuge Chen
  xiugec@student.unimelb.edu.au
  Subject: COMP30023 Computer Systems
  University of Melbourne
*/

#ifndef PWD_CRACK_H
#define PWD_CRACK_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "sha256.h"
#include "hash_manage.h"

/**** constant ****/
#define BUFFER_SIZE 1024
// number of bits of each byte
#define NUM_BIT_PER_BYTE 8
static char const * const DICT_FILE_PATH = "./resources/passwords/common_passwords.txt";
static char const STRAT_CHAR = ' ';
static char const END_CHAR = '~';

/*
  public interface using to call password cracker
  INPUT: hash_file: mandatory, the file contains all SHA256 hash results (32 bytes for each)
        pwd_file: optional, the file contains all passwords in text,
                  if specified cracker will check each password with hash results
        num_guess: optional, the number of guesses will be performed, -1 if no restriction
        pwd_len: optional, the length of password, -1 if no restriction
*/
void crack_pwd(const char* hash_file, const char* pwd_file, const int num_guess,
  const int pwd_len);

// helper functions
/*
  search passwords
  Try flexible dictionary attack and smart brute force attack first since these
  technologies could help the program verify the mostly likely passwords first.
  Then try lazy brute force attack(check all possible outcomes)
  For detailed description, please refer to README.
*/
void search_pwd(BYTE** hash_result, const int hash_len, const int num_guess,
  const int pwd_len);

/*
  compare password stored inside pwd_file (line by line) with hash results
  stored inside hash_result (32 bytes by 32 bytes)
  Return the number of guessing password stored inside of pwd_file.
*/
void compare_pwd(BYTE** hash_result, const int hash_len, const char* pwd_file,
  int* left_guess);

/*
  Dictionary attack and smart brute force attack
  #include <.h>f password length has specified, try to match all the substrings of
  each password in dict_file that has the same length. Else, try to match all
  passwords list in the dict_file.
  While going through each password (or substrings of passwords), also perform
  smart brute force attack, which basically does the expansion that combines the
  serveral rules.
  It helps the program to verify those passwords that are more likely to be
  generated by human first.
  For detailed description, please refer to README.
*/
void dict_attack(BYTE** hash_result, const int hash_len, int* left_guess,
  const char* dict_file, const int pwd_len);

/*
  lazy brute force attack (try all possible outcome)
  **** only support password length 4 ****
  For detailed description, please refer to README.
*/
void lazy_BF_attack(BYTE** hash_result, const int hash_len, int* left_guess,
  const int pwd_len);

/*
  get the next line from file descriptor and store it to buffer
*/
bool get_next_line(FILE* fp, BYTE* buffer);

#endif
